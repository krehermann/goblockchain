Add network tests

The code in main was too confusing. Turn it into a real test

Episode 19: syncing blocks
https://youtu.be/zZkLI3FlW6k



Episode 18: custom smart contracts
https://youtu.be/fom_Zx2gXOk

Create tx that houses VM byte code for addition and broadcast to all nodes

Simplify the stack. I'm confused about how a stack-based VM can reuse variables.

But perhaps i'm overcomplicating it. I had been thinking about

a = 2
b =3
a+b
b-a

but i'm ignoring the fact that a program like that has to be compiled to byte code

the stack doesn't actually need to be reused. instead the compiler would 
be responsible for push a and b onto the stack for the corresponding addition
and subtraction expressions.

Anyway, the vm.Exec needs to Pop rather than read values. This became obvious 
when I tried to create a transaction with the instructions for the expressions
'abc'=2+5

I had implemented InstructionAdd as Read rather than Pop, but then it's not
possible to have the 'abc' and '7' next to each other in the stack when calling 
InstructionStore.


Episode 17: virtual machine contract state
https://youtu.be/rLxm4F6V1K4

Add generic state tracker to vm package. Diverged from videos by
making the state track `any` rather `[]byte`. Made the interface between
the stack and state easy, but perhaps will bite me later and need to be 
refactored.

structured table-driven testing paid dividends. i never would have been able
to follow all the byte codes and logic in the video. instead, i got lucky a 
couple Episodes ago and elected to have table-driven test for vm.Run, which
made the implementation in this segment much easier to think about than the
hardcode details in the live stream 

Episode 13: broadcasting blocks

I wasted a lot of time because I didn't have a test for DefaultRPCDecodeFunc.

I implemented the block broadcasting, but forget a single line in that func and chased 
my tail for a while. Next time, add a unit test first

Then, when I figured it out, i attempted to add a unit test, but got very confused
with RPC vs Message vs Decoded Message.

Added some clarity by changing the transport interface and adding comments

Self Study: Update the mempool implementation

Anthony did this offline here
https://github.com/anthdm/projectx/commit/6b7b3c6b6b46877950cf15d518b2dea4bb4842ad#diff-65ddbfca57544ad3aaedea5dbb6e4911bbe40753fb680c41a527dccff59311eb

More or less follow along. However, observe that his SortedMap is not really sorted. it
is ordered by Add operation.

A cleaner implementation would be a generic sorted map. As it stands the List and map 
are entangled a bit too much

Note: my implementation caps the pending transactions as well as the transaction history


Episode 12: add transactions to block

for now add all transactions from mempool into block. later need to limit
the number based on some size or complexity

plumb logger to blockchain. using functional opts very nice, with slight startup overhead

it's getting confusing with the broadcasting and transactions. need a way to think about
and test this


Episode 11: creating blocks

problem in server.Start:
1. the ticker is only needed is the server is a validatore
2. the rpc receiver can block the the ticker. this is very bad b/c it means that
    the blocktime is not reliable

choosen solution:
refactor the start code to be composed of two go routines, one to handle incoming rpc and
one to handle validator

Implement createBlock in server
Add DataHash to blocks -- done in Sign, which is different and seemingly (much) easier than the validatore



